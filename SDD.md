SerenitySpark – Software Design Document

---

## ⚠️ ARCHITECTURE UPDATE (November 2025)

**Change**: Removed `@shopify/react-native-skia` dependency and replaced with pure Reanimated + React Native Views.

**Reason**: Skia was causing installation timeouts due to C++ compilation requirements. The build was hanging indefinitely during `yarn install`.

**Impact**:
- ProgressRing component: Now uses rotating semi-circle Views instead of Skia Canvas
- CompletionAnimation: Now uses individual Animated.View particles instead of Skia Canvas
- **Visual appearance**: Identical to original Skia design
- **Performance**: Equal or better (native Reanimated optimization)
- **Benefits**: Faster installs, faster builds, smaller bundle size

**Note**: Throughout this document, references to "Skia" should be understood as now implemented with pure Reanimated and React Native primitives. See [SKIA_REMOVAL_SUMMARY.md](SKIA_REMOVAL_SUMMARY.md) for technical details.

---

Introduction

SerenitySpark is a gesture-driven meditation app designed for offline use on iOS devices. It offers customizable timed meditation sessions with rich, interactive animations and an intuitive UI. The app’s core purpose is to help users quickly start a meditation of 5, 10, 15, 20, or 30 minutes with optional background nature sounds or music ￼. By leveraging React Native technologies, SerenitySpark provides a fluid, modern experience: gorgeous physics-based animations (including an impressive animated splash screen) and smooth gesture-based navigation similar to popular apps like Facebook or Tinkoff Bank. All functionality works completely offline – an offline-first design where the app can perform all core features without internet access ￼. Monetization is planned via in-app purchases (e.g. unlocking additional content), though premium features are not implemented in the initial version (IAP stubs are in place but inactive). The primary platform is iOS, but the cross-platform React Native codebase ensures Android compatibility in the future. This document details all screens, components, animations, UX, and UI styles in depth, emphasizing a production-ready implementation using JavaScript and React Native libraries.

Objectives and Scope
	•	Offline-First Functionality: Provide full app usage with no network connection. All meditation content (audio and visuals) is stored on-device so users can meditate anywhere. The design follows offline-first principles to ensure core features (timers, audio playback, progress tracking) work without internet ￼. Any data updates or sync (if added later) will seamlessly integrate but are out of scope for now.
	•	Gesture-Oriented UX: Embrace gesture-based navigation and controls to minimize on-screen buttons and enhance intuitiveness. Most actions (selecting a session, starting/ending sessions, navigating between sections) can be done with swipes, taps, or other gestures, providing a modern, immersive experience. This approach follows the industry trend where gestures replace traditional UI chrome for a cleaner interface ￼ ￼. Users can, for example, swipe between app sections, drag on selectors, and swipe to open menus – similar to interactions in apps like Facebook.
	•	Rich Animations and Visual Appeal: Implement abundant high-quality animations using React Native Reanimated 3 and React Native Skia. Animations include a splash screen with a physics-based logo animation, smooth screen transitions, interactive gesture feedback (e.g. cards smoothly following swipe gestures), and calming visual effects during meditation. These animations should run at 60 FPS for a buttery-smooth feel ￼ ￼. All animations and drawings will be done with JS and RN libraries (no native code required) – ensuring cross-platform compatibility.
	•	iOS-Centric Design (Production-Ready): Align with iOS Human Interface Guidelines for look and feel, while utilizing React Native’s capabilities for cross-platform. The app uses iOS design patterns (safe area spacing, font styles, gesture conventions) to feel native to iPhone users. Performance and stability are prioritized: using native UI threads for animations (via Reanimated) and optimizing asset loading so the app is launch-ready for the App Store.
	•	Monetization (Future Scope): The design accounts for an upgrade path to premium content via In-App Purchase. While not active in version 1.0, the architecture includes placeholders for IAP (e.g. a premium content section or locked features) that can later be activated. No server verification is needed for now; IAP logic will use storekit via a React Native module when introduced.

Out of Scope: User accounts/login (all data is local), social sharing features, and online community aspects are intentionally omitted to keep the app fully offline and focused. Also, any form of guided voice meditation or multi-day courses are deferred – the initial release sticks to self-guided timer sessions with ambient audio (the client confirmed no voice guidance or complex courses in this phase).

Technical Architecture

Platform & Framework: SerenitySpark is built with React Native (latest version) ensuring cross-platform capability. The primary target is iOS (optimized for iPhone screen sizes), and testing will ensure it meets App Store standards. The app is structured in JavaScript/TypeScript with functional components and React hooks for state management. We leverage the following key libraries:
	•	React Native Reanimated 3: Powers all complex animations and gesture interactions. Reanimated offloads animation computations to the native UI thread, enabling silky 60 FPS motion even with complex transitions ￼ ￼. Its declarative API and integration with react-native-gesture-handler allow us to create gesture-responsive animations (e.g. dragging, swiping) with minimal latency ￼ ￼.
	•	React Native Skia (@shopify/react-native-skia): Used for custom 2D graphics and effects. Skia provides a performant canvas for drawing shapes, gradients, and animations directly in RN. We use Skia for rendering the animated splash logo, dynamic backgrounds, and any custom visualization during meditation. Skia allows drawing beyond basic Views – e.g. complex shapes, shaders, and image filters ￼ – all animated smoothly via Reanimated’s shared values and worklets ￼. This combination lets us achieve rich visuals (like a logo shattering into pieces or a waveform animation) at high frame rates.
	•	React Native Gesture Handler: Manages low-level gesture recognition (swipes, pans, pinches) integrated with Reanimated. Custom gesture recognizers are attached to interactive components (like swipeable cards and draggable handles) to provide a natural, touch-responsive UI. Using this library ensures complex gestures (swipe to navigate, pan to adjust) are fluid and don’t conflict with the OS gestures.
	•	Data Storage: For offline data persistence, we use light-weight local storage. Since data is simple (user settings, completed session logs), AsyncStorage or a small SQLite DB (via RN SQLite or WatermelonDB) can serve as the local database. The local store holds meditation history (timestamps, durations) and user preferences (e.g. last used sound setting). No remote sync is needed, but the model is ready to sync if internet becomes available (e.g. if a cloud backup feature is added).
	•	Audio Playback: The app includes background sounds/music for meditation. We utilize a React Native audio module (such as expo-av or react-native-sound) to play looping nature sounds and ambient music files packaged with the app. All audio files are stored locally (downloaded or bundled) to enable offline playback. The audio module allows mixing two tracks (nature + music) concurrently if both options are enabled. The architecture isolates audio logic so it can be swapped or extended (e.g. adding more tracks in future).
	•	IAP Module (Placeholder): Though IAP is not implemented now, the codebase is structured to include a module for purchases. We plan to use a library like react-native-iap when enabling monetization. For now, premium features are simply unlocked for all users, and UI elements that would trigger purchase are either hidden or display a “Coming Soon” message. This ensures no disruption in current functionality but makes adding IAP straightforward later.

Component Structure: The app follows a modular component design. Major screens are React components contained in a navigation container (since the app is small, we can use a stack navigator for modal screens and custom gesture logic for primary navigation). State is lifted to a top-level context where needed (e.g. a Context for theme or a simple Redux store if complexity grows, though likely unnecessary here). Each screen’s UI is further composed of reusable smaller components (buttons, cards, etc.), promoting maintainability.

For example, we have: DurationCarousel component for the swipeable duration selector, SoundToggle component for audio option buttons, MeditationCanvas for the Skia-drawn meditation visualization, etc. This modular approach ensures each part (UI, animation, logic) is testable and replaceable. All features are implementable with RN and JS – no custom native modules are required beyond well-supported libraries, keeping the app within the realm of what a JS developer can build.

UI/UX Design Overview

SerenitySpark’s user experience is crafted to be minimalistic, intuitive, and visually engaging. The UI uses a calming aesthetic – a dark-themed backdrop with nature-inspired imagery, smooth typography, and plenty of animated feedback to delight the user. Gesture interactions are employed wherever possible to reduce reliance on buttons and create a seamless flow between actions. Below, we describe each screen in detail, including layout, components, animations, and interactive gestures. All icons and graphics are sourced from high-quality remote image libraries (e.g. Pixabay, Pexels) or vector icon sets, ensuring a polished look without using any emoji.

Splash Screen – Animated Logo

Upon launching the app, users are greeted with an impressive animated splash screen that establishes SerenitySpark’s branding and creative flair. The splash screen features the app’s logo (a serene symbol, e.g. a lotus flower or meditation silhouette) centered on a plain background. For the first instant, iOS will show the static Launch Screen (using the storyboard image of the logo on a neutral background, per iOS requirements). Then our React Native app takes over and plays a physics-based logo animation:
	•	Physics Logo Breakdown: The logo initially appears solid, then after a brief pause it shatters into multiple pieces that tumble and fall as if under gravity. This uses a JavaScript physics engine (Matter.js) combined with RN Skia to render the logo fragments. Each fragment is a Skia-drawn shape (or an image mask) that we animate with realistic motion (gravity, collisions) before they fade out. By leveraging Matter.js for physics calculations and Skia for drawing, we achieve a smooth effect – a technique successfully used in the RN community for interactive animations ￼. The fragments might, for example, collide with the bottom of the screen and then disappear, creating a playful breakdown effect.
	•	Twisting Text (Alternative): In another variant (possibly on a different launch or as the second phase of the splash), the app name text rapidly twists into view. Each character might rotate or swirl in, forming the name “SerenitySpark” in a dynamic way. This can be done by drawing text paths in Skia and animating their rotation/skew via Reanimated. If using Skia’s text path APIs, we can achieve complex text animations easily (e.g. a spiral motion) while preserving clarity ￼.
	•	Transition to Home: After the ~2-second animation, the app smoothly transitions to the main content. We fade out the background or zoom the camera into one fragment until it fills the screen, which cleverly becomes the background of the Home screen. This transition is handled via Reanimated worklets to ensure zero jank. No manual tap is required – the splash auto-advances – but we ensure it doesn’t linger too long to respect UX.

Throughout the splash, performance and polish are key. Animations run at native frame rate with no freezes (thanks to offloading to UI thread via Reanimated ￼). Additionally, we include a skip gesture: if the user taps or swipes during the splash, we interpret that as an intent to skip the intro and immediately navigate to Home (useful for repeat launches). This tap-to-skip is implemented by listening to touch events on the splash view.

Visually, the splash uses vivid colors and effects to captivate the user. For example, if the logo is a lotus, it might be drawn in a glowing gradient (e.g. soft purple to teal). When it shatters, particles could emit a subtle glow. We might also use a haptic feedback at the moment of breakdown – a light vibration to accentuate the effect. All these details make the first impression memorable.

Home Screen – Session Selection

The Home screen is the central hub where the user selects their meditation session parameters (duration and sound) and begins the session. The design is clean and uncluttered, encouraging a quick start while also inviting exploration via gestures. Key elements of the Home screen:
	•	Background & Header: The backdrop is a calming background image or color gradient that sets a relaxing tone. It could be a static image of a serene landscape (e.g. a sunset over the ocean or a quiet lake scene) or an animated subtle gradient. The background might even change depending on time of day (e.g. a dawn image in the morning, dusk at night) to create a contextual mood. This image is loaded from local assets (sourced from Pixabay/Pexels, such as a tranquil nature photo) and is optimized for performance (perhaps downscaled and cached). There is no traditional navbar at the top; instead, we use the whole screen for content, with a small status text or icon at top if needed (like a settings icon). The title “SerenitySpark” might be displayed in a large, friendly font near the top as a welcome, or we might simply use an icon logo at top-center for branding. By avoiding a heavy top bar, we maximize content space in line with gesture-nav best practices ￼.
	•	Duration Selector (Swipe Carousel): At the heart of the Home UI is the duration selection control, implemented as a swipeable carousel of options. Five cards or tiles are presented, each corresponding to a meditation length: 5, 10, 15, 20, 30 minutes. Only one card is centered and enlarged at a time, indicating the current selection. Users can swipe left or right to cycle through durations – an interaction more tactile and fun than a dropdown or buttons. As the user swipes, an animation smoothly slides the cards, with the centered card gently scaling up and others scaling down, giving a sense of depth. This is realized with Reanimated: the scroll position drives an useAnimatedStyle on each card to interpolate its size and opacity, producing a smooth carousel effect. The swipe gesture is powered by the gesture handler’s Pan recognizer (horizontal pan), configured to snap at each card. This way, a quick flick will glide to the next duration and snap into place with a slight spring animation (to add a playful bounce). For discoverability, we include subtle visual cues: for instance, part of the next card peeks out at the edge, and maybe small dots below the cards indicate there are multiple options (similar to a page indicator). This addresses the issue that pure gestures can be hidden – we hint at it visually ￼. Each duration card shows the number of minutes (large numeral and “min” label) and could include a representative icon or image. For example, a “5 min” card might show a simple icon of a short clock or a person sitting briefly, whereas “30 min” might show a more extended pose or a larger clock icon. We use vector icons (from a library like Material Community Icons or Ionicons) for these illustrations – e.g. a clock face icon – to keep them sharp and lightweight (no emojis or raster images for icons, per guidelines). The styling of cards is consistent: perhaps a rounded rectangle with a slight glassmorphism effect (translucent blur) or a soft pastel color distinct for each duration (making it easy to differentiate as the user swipes).
	•	Sound Options (Toggle Buttons): Below the duration carousel, the user can choose their ambient audio for the session. There are two toggle buttons: Nature Sounds and Music. These are presented as icon-based round buttons or pill-shaped toggles with labels. By default, both are off (or perhaps one is on based on last use). The user can tap either to enable that sound. If both are toggled on, the session will play both tracks mixed (the app supports simultaneous playback of one nature track and one music track, as requested). Each button has an intuitive icon: for Nature, we use a vector icon of a leaf, water, or forest (to represent nature sounds like rain, forest ambiance, etc.), and for Music, a musical note icon. When toggled on, the button icon will fill with a highlight color and perhaps animate (e.g. a small glow or a checkmark appears). The toggling has a satisfying tactile feel: using Reanimated, we can add a slight spring animation on press (the button scales up then down to simulate a press feedback) and maybe a short vibration using Haptic feedback API for confirmation. The user can also change these via gestures: e.g. a swiping toggle – but tapping is straightforward here, so we primarily keep it as a tap. However, to stay gesture-friendly, we ensure the toggle buttons are large and thumb-friendly (so it feels like a natural extension of touch gestures). The labels “Nature” and “Music” might appear below the icons or on the toggles themselves for clarity. The app remembers the last used sound settings locally, so returning users find their preferred ambiance pre-selected.
	•	Start Meditation Button: Front and center, we provide a prominent Start action. After choosing duration (and optionally sounds), the user taps Start to begin. The Start control could be a distinct circular button with a play icon, positioned toward the bottom of the screen (but above any persistent nav). It could also be integrated into the carousel – for example, when a duration card is centered, that card itself may have a “Tap to Start” area, so the user can simply double-tap the card to start. However, for clarity, we’ll implement a dedicated Start button that fades in or becomes active once a duration is selected. The button’s style is a vibrant accent color (contrasting the background, e.g. a calming blue or green) with a play icon (▶️) from a vector set. We avoid using the word “Start” on the button to keep it universal (iconography suffices). The button has an animated ripple effect on press (using RN Pressable’s Android ripple on Android, and a custom Skia ripple on iOS to mimic water ripple). Additionally, as the user presses Start, we might trigger a brief scale-up animation on the button and fade out the other UI elements, transitioning into the session screen. There’s also a plan for a swipe gesture to start: for power users, swiping the carousel all the way to the left beyond the first item could act as a quick start gesture, but this is an enhancement that we might evaluate later – initially, the button is the primary method to avoid accidental starts.
	•	Navigation Gestures: Although the Home screen is mainly for starting sessions, we incorporate edge-swipe navigation to access other parts of the app. Specifically, a swipe right from the left edge will open the Settings/Info panel (or a side menu), and a swipe left from the right edge opens the History screen (meditation log). These gestures mirror the idea of side-drawers or lateral nav but without persistent menu buttons on screen. Visual hint: a slight arrow or edge shadow may indicate this capability (for example, a tiny sliver of the settings screen might be visible at the extreme left as a cue). We ensure these swipes do not conflict with the carousel swipe by distinguishing gesture regions (edge swipe only triggers nav if started at screen edge, whereas carousel swipes start in the carousel area). This approach keeps the UI minimal yet accessible. It aligns with iOS standard of swipe-from-edge to go back; here we adapt it for our custom nav (as there’s no traditional back stack from Home, we use it for drawer-like nav).
	•	Onboarding Tip: For first-time users, because the interface relies on gestures, we include a gentle onboarding overlay on the Home screen. The first time the app launches, an overlay can appear with a few arrows or text hints: e.g. “Swipe to choose duration” with an arrow icon, “Tap icons to add nature sounds or music”, and “Swipe from edges for more”. These hints ensure discoverability of gestures ￼. We implement this as a modal that appears over the home UI with semi-transparency. The user can tap anywhere (or perform any gesture) to dismiss it. It only appears the first time (tracked via AsyncStorage flag). Additionally, subtle persistent cues remain – like small arrows at the edges or the aforementioned peeking elements – so even those who skip onboarding can intuit the interactions.

Overall, the Home screen’s UX is focus-first: within a second of launch (post-splash), the user can, with one swipe and one tap, start a meditation. Defaults (like 5 minutes, no sound) are selected so that technically a single tap on Start from the get-go begins a quick session. Advanced interactions (changing sounds, viewing history) are available but do not clutter the primary flow.

Meditation Session Screen – In-Session Experience

Once a session begins, the app transitions to the Meditation Session screen. This screen is deliberately minimal to avoid distractions and immerse the user in a calming experience while the timer runs. It occupies the full display with no visible navigation or extraneous UI – just the meditation visualization, timer, and a way to end or pause if needed. Key components and behaviors on this screen:

During a meditation session, the app’s interface is tranquil and minimal. A serene visual (like a person meditating by a calm lake) can be used as a background or thematic image, reinforcing relaxation and focus. The example above illustrates the kind of peaceful scene that might be displayed softly behind the session timer.
	•	Visual Background & Theme: The session screen often uses a dark mode or very soft visuals so that the screen isn’t harsh on the eyes (important if eyes are semi-closed or if user is in a dark room). The background might be a solid dark color (e.g. deep navy blue or charcoal) or a very subtle gradient. We avoid any bright white UI. Optionally, we may overlay a faint animated graphic to enhance focus: possibilities include a slowly moving gradient blob, gentle particles floating (like dust in light), or a dimmed nature scene related to the chosen sound (e.g. if rain sounds, maybe a faint silhouette of rain droplets falling in the background). These visuals will be done via Skia for efficiency, but kept very low-key – more like an abstract ambiance than an animation to watch. The idea is to provide something softly dynamic if the user’s eyes are open, without demanding attention.
	•	Timer Display: At the center (or slightly above center) of the screen, we show the meditation timer. There are a few design options for this timer, and we can combine them for clarity:
	•	A circular progress ring around the perimeter of the screen (or around a central icon). For example, a ring that gradually completes a circle over the course of the session. This can be a Skia-drawn circle that we animate using a time-driven shared value. At session start, the ring is 0% filled; by the end, it’s 100% (a complete circle). The ring could be a soft colored stroke (e.g. a gentle cyan or purple) that subtly glows. This provides a visual sense of progress without needing to look at numbers.
	•	A numeric countdown in minutes and seconds, placed at center or bottom. For users who prefer to know the remaining time, we can display the count (e.g. “14:59” counting down). This text is in a large, thin font, semi-transparent. However, some meditation philosophies suggest not fixating on time, so we might allow this to be hidden. Perhaps by default we just show the circle, and a gentle tap on the screen can toggle the numeric time display on or off. (This tap won’t end the session, it’s just a UI toggle).
	•	Guided Breathing Animation: An optional feature is a breathing guide – for instance, a circle that expands and contracts rhythmically (like the popular breathing exercise visuals). We could synchronize it to a calm breathing pace (e.g. 4 seconds inhale, 4 hold, 4 exhale, etc.). This can help users focus on breathing. If we include this, it’d be a translucent circle in the center that pulses. Implementation: use Reanimated’s repeat timing to animate scale up and down of a View or Skia shape. The user can ignore it if they want, but it’s there as a focus anchor. This is not a guided audio, just a visual. Since the question didn’t explicitly ask for breathing exercise, this is a bonus consideration – we can decide based on user feedback.
	•	Audio Playback: If the user enabled Nature and/or Music, those tracks play in the background throughout the session. There is no on-screen UI for audio controls during the meditation (to minimize distraction). We assume the user set their volume prior (device volume) and the mix is pre-balanced (e.g. if both sounds, we might slightly lower each so they blend). The audio module handles looping so that, for example, a 5-minute rain sound seamlessly loops if shorter. To add a touch of interactivity, we could reflect the audio in the visuals: e.g. if music is playing, tiny pulsating bars or a waveform at the bottom could animate to the sound. But this might break the calm mood, so likely we keep it static. Instead, maybe a small icon on-screen indicates which sounds are on (like a leaf icon and note icon somewhere), mostly for information. The user can’t toggle them here, it’s just showing “rain sound and music are playing”. If they really need to change it mid-session, they’d have to end and restart (since the assumption is one doesn’t frequently toggle during meditation).
	•	Controls (Pause/End): By default, the session runs to completion without interruption. However, we must provide a way to end early or pause if needed. We handle this in a subtle way:
	•	A “Finish” Gesture: The user can swipe down anywhere on the screen to end the session early. This swipe-down is a common gesture to dismiss in iOS (like pulling down a modal). When detected (a vertical pan from top to bottom exceeding a threshold), we interpret it as “end session”. We accompany it with a confirm interaction – perhaps the app will momentarily show an overlay “Release to end session” when the swipe is halfway, to ensure it’s intentional. If the user continues, the session will end. (Alternatively, a double-tap could be used to end, but double-tap might conflict with toggling time display as proposed. Swipe-down feels more natural and less likely accidental.) We ensure that this gesture does not conflict with system gestures (starting mid-screen avoids triggering Notification Center which requires swipe from top edge).
	•	A Pause feature is optional – many meditation timers don’t pause (since meditation is time-bound), but if needed, a tap with two fingers (a common gesture to pause media) could pause the timer and audio. This would dim the screen and show a “Paused – tap to resume” message. Given simplicity, we might skip explicit pause and only allow end; meditations are short and presumably users won’t pause often.
	•	Additionally, we can have a physical control: if the user finds gestures unintuitive, a small “X” or “Stop” button can appear when they tap the screen once. For instance, tapping the screen (if not used for showing time) could bring up a minimal overlay with a stop button and maybe the elapsed time. This overlay auto-hides after a couple seconds of no interaction. This way, those uncomfortable with gesture-only control have a fallback. The stop button will use an icon (like a square or power icon) and will also require confirmation (maybe a long press or a second tap to confirm, to prevent accidental exits if they just wanted to see time).
	•	Throughout, we maintain the ethos that most interactions are gestures – so the UI doesn’t show persistent buttons unless summoned. This keeps the session view extremely clean.
	•	Animations in Session: We want the session to feel alive but not distracting. Some animation ideas implemented with Reanimated/Skia:
	•	The background gradient could slowly shift colors over time (e.g. cycling through a subtle palette) to subconsciously mark time passing. For example, in a 10-minute session, a blue gradient might slowly drift towards purple. This can be done by interpolating color values on a Skia canvas fill over the duration.
	•	If using a nature scene image, we could apply a slight parallax or Ken Burns effect (slow zoom/pan) on it to avoid it being completely static. However, too much motion might distract, so we’d use a very slow, gentle zoom-out or in.
	•	The progress ring itself can animate not just in filling but maybe have a glow pulsing – e.g. every time a minute completes, the ring could momentarily glow or thicken then resume normal. Or at the halfway mark, a gentle pulse as feedback.
	•	If the breathing circle is used, that itself is an animation guiding the user’s breath.
	•	We will utilize Reanimated’s timing and spring functions to ensure these animations are smooth and synchronized with real time. Because Reanimated runs them on the UI thread, timing will remain accurate even if JS thread is busy ￼ – crucial for a timer.
	•	During-Session Gestures: Other than swipe down to finish and the optional tap to toggle time/pause, we deliberately limit interactions. We want users to focus on meditating, not fiddling with the app. So common gestures like pinch or swipe left/right do nothing (to avoid accidental triggers). We disable the edge-swipe nav during a session to prevent accidentally leaving (iOS might catch swipe-from-left as back – but since Home is root, it wouldn’t do anything; still, we can intercept it to be safe). Essentially, once in session, the only expected gesture is swipe-down to end. This simplicity prevents confusion in a mindful state.

When the timer reaches zero (session complete), the app will gently transition to a completion state.

Session Completion and Transition

At the end of the meditation duration, the app provides feedback and returns the user to the Home screen (or possibly a summary screen). The completion should be handled in a gentle and rewarding manner, aligning with the calm experience but also acknowledging the user’s accomplishment. Here’s the flow and elements:
	•	Completion Alert: When time is up, if audio was playing, we might play a soft chime or bell sound to signify the end (a common practice in meditation apps). This sound is built-in and will play regardless of the chosen ambient audio (which might still be playing; we can fade out the ambient and play the chime on top). Visually, we could flash or pulse the screen border or the progress ring to catch attention subtly. For instance, the progress ring might do a quick 360° highlight sweep or the entire screen might momentarily brighten then return to normal. This gives a cue even if the user isn’t looking directly.
	•	“Session Complete” Overlay: We overlay a message such as “✓ Session Complete” or an encouraging phrase (“Well done!”) at the center. This text fades in. We might accompany it with an animation of a small confetti or particles – e.g. a few sparkles rising or a very light confetti (not party-like, but maybe petals or leaves drifting upwards) to celebrate. Using Skia, we can generate these particle effects efficiently. For example, draw small lotus petals that gently float up, using a physics or randomness for natural motion. This animation should last a second or two and then fade. It adds a bit of positive reinforcement.
	•	Transition to Home: After a couple of seconds of showing the completion state, the app automatically navigates back to the Home screen so the user can either close the app or start another session. The transition is smooth: we might fade out the session screen or shrink the content into a small circle and then reveal the Home UI behind it. Another idea: the completion overlay (the checkmark or text) could scale up and become the logo on the Home screen. However, since the Home doesn’t have a big logo normally, a simpler crossfade is fine. We use Reanimated’s withTiming to fade out and simultaneously fade in the Home components, making it feel like one continuous scene.
	•	Reset UI State: When Home appears, the previous selection and toggles remain as they were (so if the user wants to do the same again, they just hit Start). We could optionally advance to a next default (some apps rotate suggestions, but here durations are fixed, so no change).
	•	History Logging: In the background, the app logs this session completion to local storage (duration, timestamp). This will be used in the History screen. This operation is quick and offline. We ensure it doesn’t cause any visible lag in the UI transition.

If the user ended the session early via gesture, we still show a completion, but possibly a different message like “Session Ended” rather than the checkmark (to differentiate from full completion). But we still log whatever minutes they did if we want to track partial (or we may choose to only log full sessions to keep stats neat).

Throughout the completion process, we remain non-intrusive. We explicitly avoid any disruptive pop-ups (like rating prompts or ads) at this point, since it’s meant to be a mindful moment. Monetization will not hijack this moment; if we ever prompt for subscription, it would be in a more neutral context like on app reopen or a dedicated screen, not immediately after a meditation.

History Screen – Session History & Stats

The History screen provides the user with feedback on their meditation practice over time. Since the app is offline, this is a simple local log of sessions. It’s accessible by swiping left from the Home screen (or via a menu). The design is straightforward and encouraging, offering stats without overly gamifying (unless decided otherwise later).

Layout & Content:
	•	The top might have a section “Your Journey” or simply “History”. We present a chronological list of past meditation sessions (most recent first). Each entry shows the date/time and duration. For example: “Today 09:00 – 10 min” or “Oct 30 – 5 min”. We group entries by day or month if there are many. This list is scrollable vertically. The user can swipe up/down to scroll through past entries (standard ScrollView). Swiping right from the left edge will navigate back to Home (as per iOS back gesture, or they can swipe right since Home is to the right in our horizontal navigation scheme).
	•	Gesture Tip: The user likely reached History via edge swipe, but we also allow a left-edge swipe from History to go back (mirroring a back gesture). We make sure not to conflict with any row swipe (if we had swipe-to-delete for entries, but probably unnecessary here).
	•	Possibly, each entry can have an icon representing if it was full session or ended early (maybe a different mark if they didn’t complete, but we might not complicate that).
	•	Statistics Summary: At the top or bottom, we include a summary block: e.g. “Total sessions: X” and “Total minutes meditated: Y”. Maybe also “Current streak: N days in a row” if we want to motivate daily use. This data is derived from the history. It gives the user a sense of accomplishment. The styling is subtle, maybe using small badges or just text. If streaks are included, we might have a small fire or star icon with the number of days.
	•	If we want a visual chart, we could incorporate a simple bar chart of the last 7 days minutes. Using Skia, draw a tiny graph. However, given this app’s simplicity, a full chart might be overkill. Perhaps just the numbers suffice. We aim to keep this screen simple as well, since detailed analytics aren’t the main focus.

Visual Style:
	•	The background of History can reuse the Home background or a simpler solid color (dark theme). We maintain consistency in typography and colors.
	•	Each list item (session record) could use an icon to denote the duration (like the same clock icon or a small numeral badge). For example, a 5-minute session entry might have a “5m” icon. This is mostly redundant text, so maybe not needed if we clearly state duration.
	•	We ensure text is easily legible (likely light text on dark background).

No heavy animations are needed here, but we add small touches: when the user opens History (via swipe), the list items can fade and slide into view sequentially, providing a nice entrance. If they scroll, maybe a slight parallax with the background image could be applied (if Home had a background image, History might share it, creating a continuous feel as they swiped over – e.g. the background stays static while content moves over it). This can be done by having the background as an absolute positioned element shared between Home and History screens, and using Reanimated to link its position to the swipe offset.

There’s no direct user interaction on history entries (we don’t need editing or detailed views), so it’s mostly read-only. If ever needed, a swipe left on an entry could delete it (with a confirmation snackbar maybe), but we assume the user won’t need to delete history often. We might include a “Clear All History” button in settings instead if needed.

Settings & Info Screen

Swiping right from Home opens the Settings/Info screen. This screen contains configuration and informational items, allowing the user to adjust the app to their preference and learn about the app. Since the app is offline and simple, settings are minimal:
	•	Theme Toggle: Although the app is primarily in a dark theme for meditation, we might allow a light theme if some users prefer (or an auto theme by time). A toggle for Dark Mode could be here, which would switch the color scheme of the app. (On iOS, we can default to system theme, but given our design is heavily dark by nature, this toggle is optional).
	•	Sound Options: Possibly allow the user to select which specific nature sounds or music track they prefer if multiple are available. For instance, under settings, “Nature Sound: [Rain /]” (a dropdown or list to choose Rain, Forest, Ocean, etc.) and “Music Track: [Piano /]” (choose from a few). In the main UI we only had on/off toggles, which by default use a default track (say rain for nature, and a calm ambient for music). In Settings, the user can change the default tracks. This way the Home toggle remains simple (just on/off), but this setting gives customization. We will list available sounds (which are bundled audio files) and possibly provide a preview play button for each (though offline, we can play them immediately). The UI for selection can be a simple list where tapping one marks it as the default (with a checkmark).
	•	Reminders (if any): Not in initial scope, but if we consider adding a daily reminder notification (“Remind me to meditate at 8am”), this is where the toggle would be. The user could set a daily reminder time. However, earlier responses indicated “no” possibly to some questions, maybe they didn’t want notifications. We will skip implementing this now (and it’s tricky offline, though local notifications are possible without internet). We note it as a potential future feature.
	•	About & Help: This section shows the app version, developer info, perhaps a short description of the purpose. If the app had any instructions beyond onboarding, they could be reiterated here (like “How to use gestures” help text). We keep it brief. Possibly an “FAQ” link (just static text in-app since offline) covering what to do if something isn’t clear.
	•	Privacy: Since no data leaves the device, we mention that in a Privacy note. This builds trust that meditation data is private.
	•	IAP / Premium: Currently inactive, but if we plan a premium upgrade, this screen might have a “Go Premium” button or list benefits of upgrading. Since IAP isn’t implemented now, we either hide this or label it as coming soon. If visible, tapping it could either do nothing (or show a “not available yet” dialog), or we grey it out.

Navigation & Layout:
	•	The Settings screen likely slides in as a drawer or modal from the left. We can visually treat it as an overlaying panel that covers part or all of the Home screen. For a modern feel, perhaps a bottom tab bar is overkill for such few screens, so this slide-out approach works. We might style it as a side drawer: when swiped in, the Home screen in background scales or darkens slightly, and a panel containing settings occupies 80% width from left. This panel can have a blurred translucent background (to maintain the serene style, akin to iOS contextual menus). Or we can make it a full screen takeover (like navigating to a new screen).
	•	A close gesture is naturally swipe left (reverse of open) or tapping the semi-transparent backdrop.
	•	If it’s a full screen push, a swipe right from left edge would normally pop it (iOS back), which is intuitive. We will support that too if we go that route, but likely it’s a drawer for style consistency with gesture nav.

Appearance:
	•	Continue the calm theme: maybe use a soothing color for icons/switches. The text is likely white on dark. Each setting item is in a list form with a clear label and control. For example: “Dark Theme: [ On / Off switch ]”. We use native-style switches or custom styled toggles (RN Paper or similar could be used, but a simple Switch from RN is fine).
	•	Icons: If we list sound options, small icons of a drop (rain) or waves can accompany each to visually distinguish.
	•	Minor animations: toggling a switch might animate the thumb sliding (native iOS switch does this by default). We can also animate the content appearance when opening the panel (each setting item could fade/slide in sequentially).

The Settings doesn’t require heavy gesture beyond the swipe to open/close. Inside, mostly taps. We will, however, allow the user to swipe back to Home either by the edge or by swiping the panel away.

Visual Design & Branding

SerenitySpark’s visual identity is centered around peaceful, nature-inspired imagery and smooth modern UI elements. Every visual component aims to reinforce calmness and focus:

The app’s branding can utilize serene symbols like a lotus flower emitting soft light, as shown above. Such imagery embodies the app’s meditation focus – conveying tranquility, purity, and enlightenment. We use warm, soothing colors (gentle oranges, soft greens) and glowing effects to create a calming first impression. The lotus motif, or a similar easy-to-recognize icon, can be featured in the app logo and throughout the UI, aligning the visual theme with the app’s purpose.
	•	App Name & Logo: The chosen name “SerenitySpark” evokes calm (Serenity) with a touch of energy or enlightenment (Spark). The logo reflects this: for example, a lotus flower with a small spark or glow at its center, or a person meditating with a stylized spark icon. The logo is used on the splash and maybe a small version on the Home screen. It’s designed to be simple and easy-to-remember, avoiding clichés like the word “flow” (per request). The color palette for the logo and accents is composed of soothing hues: perhaps a gradient of teal and purple, or sunset orange and pink – colors often found relaxing yet vibrant enough to be memorable. These colors also appear as accent colors in buttons or highlights.
	•	Color Scheme: Predominantly a dark background (#101020 or #000) for main screens to reduce eye strain. Text is in a light color (near white or a soft grey) with high contrast for readability on dark. Accent color (for interactive elements like the Start button, toggles, and highlights) could be a turquoise or aquamarine (connotes nature and calm). Secondary accent might be soft orange or gold (for warm highlights, e.g. the completion checkmark or spark). We ensure any color used passes accessibility contrast standards when used for text. The palette is limited to a few colors to maintain a clean look.
	•	Typography: Use a clean, modern sans-serif font throughout, preferably one that feels friendly. On iOS, the default San Francisco font is good for readability. We might use a custom font for the logo or headings if it adds character (e.g. a slightly calligraphic or light sans font for the “SerenitySpark” title). Body text and labels remain regular weight for clarity. We keep font sizes comfortable: large for important numbers (timer, duration on cards), medium for labels, and avoid tiny text. Since content is minimal, we can afford slightly larger text to enhance legibility.
	•	Icons & Images: All icons are vector-based (from libraries like Feather, Ionicons, MaterialIcons, etc.) for crisp rendering at any size. For any illustrative graphics, we use images from free libraries (Pixabay/Pexels) with appropriate licenses. These could include background photos (e.g. a nature scene used on Home or a rotating set of background images to keep things fresh) and possibly illustrations (like a meditating person outline). We reference these by URL in documentation and will bundle optimized versions in the app assets. No emojis are used; any emotive symbols (like a smile or checkmark) will be via icon or custom illustration to match the app style. The app may use a subtle animation library for icons – e.g. Lottie – if we want something like an animated checkmark or loader, but currently most animations can be done with Reanimated/Skia.
	•	UI Components Style: Buttons and cards have rounded corners (to create a soft, welcoming feel). The carousel cards might have a slight drop shadow or glow when active, to set them apart. We use translucency effectively: for example, if an overlay appears (onboarding or settings as a drawer), it will have a blurred translucent background to imply depth but not stark modal blocks. This aligns with iOS’s design language of layered translucency for context.
	•	Animations & Transitions: The style of animations is smooth and easing – no jarring linear moves. We often use ease-in-out curves or gentle spring physics so things bounce lightly rather than stop abruptly (e.g. the swipe carousel snapping uses a spring for natural feel). Visual feedback animations (like button presses) are quick but not sharp, giving a sense of responsiveness without hectic motion. We refrain from overly flashy transitions that could irritate during repeated use; instead focus on delightful micro-interactions (like the toggle bounce or the slight card tilt when swiped).
	•	Accessibility Considerations: Gesture-heavy interfaces can pose challenges, so we ensure at least basic accessibility: all interactive elements (carousel items, toggles, start button) have accessible labels for VoiceOver. We also consider an alternate navigation scheme for users who cannot perform gestures easily: for instance, a hidden setting that enables on-screen navigation buttons (like “History” and “Settings” buttons) for those who prefer tapping – or simply the VoiceOver rotor can navigate. We keep font sizes scalable with Dynamic Type if possible. High contrast mode is supported by our color choices (mostly fine on dark background; if needed, we can lighten colors further in that mode). While the focus is on gestures, we provide visual and haptic feedback for them (e.g. small vibration on swipe actions) which also helps users confirm their action was registered ￼. And as mentioned, onboarding educates users on how to use gestures to mitigate the discoverability issue.

Animations and Gesture Implementation Details

This section highlights how we implement the notable animations and gesture controls under the hood, using our chosen libraries:
	•	Reanimated & Worklets: All major animations (splash logo, carousel transitions, progress ring, etc.) are defined in Reanimated worklets. For example, the carousel uses an Animated.ScrollView with a custom onScroll event that updates a shared value x. Each card’s position is then computed in a worklet as translateX = cardIndex * cardWidth - x and we use that to derive scale and opacity (with math functions) for a smooth carousel effect. Running these on the UI thread avoids frame drops, even if JS is busy ￼. Gesture handlers (like the pan for swiping cards or swipe-down for closing session) are linked to Reanimated animations via the .onUpdate callbacks – for instance, during a swipe-down, the gesture handler updates a translateY value of the session container which in turn maybe dims the background until the threshold is reached (giving a responsive drag-to-close animation).
	•	Skia Drawing: The Skia canvas is used in scenarios where custom drawing is needed:
	•	The splash physics animation: We pre-render the logo as either an array of vectors (if it’s an SVG) or as an image. If vector, we can split it into parts (e.g. break the path into pieces). If image, perhaps cut into a grid of small sprites. These pieces are then each drawn on a Skia Canvas. We then animate their x,y positions and rotations based on physics data from Matter.js. The physics engine runs on the JS thread (Matter.js is JS-based), but since Reanimated can communicate via shared values, we can feed positions to the UI thread smoothly. We might run a simulation of the shatter for a short time and store the keyframes. Given the short duration, slight JS involvement is fine; however, if we find performance issues, we could simplify physics to an approximate animation using Reanimated’s spring functions (not real collisions but an artistic approximation). The cited Reddit example shows that mixing Matter.js and Skia is viable ￼, but we will keep an eye on performance.
	•	The progress circle and breathing animation: These are perfect for Skia. We’ll use the Skia Canvas with a Paint to draw an arc for the progress. Reanimated drives the end-angle of the arc from 0 to 2π over time. Skia’s advantage is we can draw this arc with blur or glow effects if desired (using Skia shaders). The breathing circle can be a Skia circle whose radius is modulated by a sine wave via Reanimated. Because Skia excels at vector drawing and effects, we can create very custom visuals that would be hard with standard Views ￼. And since it’s all GPU-accelerated, it stays smooth.
	•	The confetti/petal particles at completion: We can either use Skia’s drawing in a loop or, simpler, use a series of small Lottie animations of a particle. However, Skia gives fine control: we can spawn, say, 10 particles with random initial velocities and use a simple gravity formula in a worklet to update their positions each frame, drawing circles or small textures. Reanimated can call a worklet on a schedule (useFrameCallback) to update these for a brief period. Given the low number of particles, this is fine. Alternatively, we could pre-create an animated GIF of confetti – but that’s less interactive. We prefer the programmatic approach for consistency with our tech stack.
	•	Gesture Navigation: We largely implement navigation via gestures rather than relying solely on a navigation library’s built-in gestures. For instance:
	•	Home <-> History and Home <-> Settings are like horizontal swipes. We can implement the Home as the central page of a three-page Animated.View stack (Settings on left, Home center, History on right). Then a Pan gesture on the whole app container could allow swiping between these pages. However, to keep it simpler, we might treat them separately: user swipes triggers an imperative navigation (like set state “showHistory”). But an animated continuous swipe feels more fluid. We might do something like: a Pan gesture on Home with translationX controlling a shared value navOffset. When the user swipes left, navOffset goes from 0 towards -width, revealing the History screen. If they pass halfway and release, we animate it to full -width (History fully in view); if not, animate back to 0. Similarly for swipe right to show Settings (navOffset to +width). This approach gives a nice interactive swipe navigation (similar to how you can swipe between tabs or pages in some apps). It’s a bit custom but definitely doable with Reanimated’s gesture support ￼. We will ensure inertia and snapping feel natural.
	•	For vertical swipe gestures (like pulling down to close session or a future pull-to-refresh if any), we use the same pattern: a Pan with vertical direction, and threshold logic. Reanimated can animate the component’s position following the finger, and on release we either keep it or snap it back.
	•	Performance Optimizations: We make sure to run heavy animations on native. Reanimated’s selling point is avoiding JS thread jank ￼, so we adhere to that: all our animation effects use functions like withTiming, withSpring on shared values. We avoid setState in animations; instead use animated styles. Skia drawings are efficient but we also avoid overdraw (e.g. not constantly redrawing huge images unnecessarily). For example, our background image is static and doesn’t need re-render each frame (unless we do the slow zoom, which we can do by incrementally scaling the image matrix rather than reloading image).
	•	We also keep the number of animated components reasonable. The carousel might have 5 items - that’s fine. The confetti has maybe 10 small shapes for 2 seconds - also fine.
	•	If at any point the device is older and can’t handle the Skia + Reanimated combo (maybe older iPhones), we will test and possibly provide a reduced animation mode in Settings (“Reduced Motion”), which could disable advanced effects (like no confetti, simpler splash without physics). This aligns with accessibility as well (reduce motion preference).
	•	Testing Gestures: We will test that gestures do not conflict or require too much precision. E.g., the swipe to nav vs. swipe on carousel: we partition the screen such that vertical swipes are recognized if mostly vertical movement, horizontal if mostly horizontal, using gesture.isolate() or gesture.requireToFail() techniques from the gesture-handler to manage priority. This ensures user-intended gestures trigger the right action. We’ll also ensure certain areas don’t accidentally trigger nav (like swiping on the carousel should not open History). Fine-tuning the gesture response is part of our polish process, referencing best practices like consistency and avoiding overload ￼.

Offline Data and Storage

Since the app works fully offline, all necessary data is bundled or locally generated:
	•	Audio files: Stored in the app bundle (e.g. in assets/ folder) or downloaded on first use and cached. We have to manage app size; including multiple high-quality audio tracks can be heavy, so we might include just a couple (e.g. one nature, one music) by default. Others can be added as optional downloads (if IAP unlocks more, for instance). But primary usage requires no internet – so initial tracks are inside the app package.
	•	Images: Background images or illustrations are also bundled. Alternatively, we could have the app fetch a new “Image of the Day” from a server to vary background, but that breaks offline. So instead, we might bundle a small set of 3-5 images and cycle them. All images are optimized (JPEG compressed for photos, PNG/SVG for illustrations as needed). In code, these are required or loaded from file, not from URL (the URLs in design docs are for reference).
	•	Storage for History: We use AsyncStorage to save a JSON array of session records (date, duration). Each session record is tiny (a few bytes), so this is efficient. On app launch, we load this to memory (or use a useAsyncStorage hook to retrieve and display). Writing on session complete is quick. No complex database needed given the simplicity. If we wanted to avoid AsyncStorage’s known performance issues for larger data, an alternative is SQLite – but likely overkill here. AsyncStorage for maybe a few hundred entries at most is fine.
	•	Settings: Also stored via AsyncStorage (e.g. booleans for sound preferences, chosen default sounds, maybe last used duration to pre-select that card next time). This ensures user preferences persist across sessions.

With offline design, we ensure the user never sees a “Loading” or “Please connect” message. Everything is instantly available. The splash animation covers any app initialization latency, so by the time it’s done, Home is ready to use with data loaded from disk if needed.

If the app in future gets cloud sync or content updates, we will incorporate a sync mechanism that runs in background when online, but it won’t affect core usage if offline.

Future Enhancements

While this SDD covers the initial feature set, there are plans for future improvements:
	•	In-App Purchases: Activate premium content such as additional ambient sound packs (e.g. more nature scenes or music tracks) or guided meditation packs. The UI will then include a Premium screen or prompts (tastefully placed, perhaps on the History screen like “Upgrade to unlock more sounds”). We will integrate react-native-iap for iOS App Store purchases and provide a restore purchases option in Settings. All premium content will also be offline (downloaded to device upon purchase). Monetization will be handled carefully to not disturb the user’s meditation flow – e.g. prompts only shown at logical times (not during or immediately after a session).
	•	Guided Meditations: Introduce voice-guided sessions as optional content. This would involve audio narration files and possibly on-screen transcripts or imagery. The UI might gain a selection for “Guided” vs “Silent” sessions. However, as user indicated, currently guided content is not to be included (they answered “no” likely to guided sessions), so this is only a consideration if requirements change.
	•	Social/Sharing Features: If ever connected online, users might want to share that they meditated or compete in streaks. A future update could allow generating a shareable graphic of their meditation stats or integrate with Apple HealthKit to record Mindful Minutes (so their meditation contributes to Health app data). Particularly HealthKit integration on iOS would be valuable to some – we’d need user permission and then we’d log each completed session’s minutes to HealthKit.
	•	Enhanced Gestures with Sensors: We could explore using device sensors for novel interactions (inspired by how some apps use tilt or shake). For instance, the Reddit example mixed device rotation with Skia for an interactive effect ￼. Perhaps tilting the phone could cause particles to drift in that direction on the splash or cause a subtle parallax in backgrounds. This is experimental and would be behind-the-scenes polish if implemented.
	•	Multi-platform and Device Adaptation: Extend testing to Android, ensuring the gesture navigations adapt (Android has back gesture too). Possibly adjust some styles for Android Material guidelines if needed (though likely not, since design is custom). Also, ensure it looks great on tablets (maybe allow landscape orientation with responsive layout).

Conclusion

SerenitySpark is designed to be a comprehensive yet tranquil meditation app that leverages modern mobile UI/UX trends – offline-first functionality, gesture-based navigation, and rich animations – to deliver a delightful user experience. By utilizing React Native with advanced libraries like Reanimated and Skia, we achieve native-like performance for animations (smooth 60 FPS effects ￼) and the flexibility to create unique visual features that set the app apart. The gesture-oriented design aligns with evolving mobile interface trends where intuitive swipes replace clunky menus ￼, resulting in a cleaner interface that still feels familiar and easy to use. Every screen and component has been detailed above, ensuring that developers understand the intended behavior, look, and feel down to each animation and icon. Crucially, all features are implementable with JavaScript and existing React Native tools, keeping the development within scope and maintainable.